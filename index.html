<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Nebula Dodge - Tacos!</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@700&display=swap');
body {
  font-family: 'Space Mono', monospace;
  background-color: #0d1117;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  margin: 0;
  overflow: hidden;
  flex-direction: column;
}
#game-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 10px;
  background: #161b22;
  border: 4px solid #00ffaa;
  border-radius: 12px;
  box-shadow: 0 0 20px rgba(0,255,170,0.5);
  max-width: 95vw;
  max-height: 95vh;
  position: relative;
}
#game-canvas { background-color: #0d1117; border-radius: 8px; touch-action: none; }
.game-controls { display:flex; justify-content:space-between; width:100%; margin-top:15px; padding:0 10px; box-sizing:border-box; }
.control-button { background-color:#00aaff; color:#161b22; padding:12px 25px; border-radius:8px; font-size:1.25rem; font-weight:bold; cursor:pointer; box-shadow:0 4px #0077cc; transition:all .1s; user-select:none; flex-grow:1; margin:0 5px; text-align:center; }
.control-button:active { background-color:#0077cc; box-shadow:0 0 #0077cc; transform:translateY(4px); }
#score-display { position:absolute; top:15px; left:22px; color:#00ffaa; font-size:1.2rem; text-shadow:0 0 5px #00ffaa; z-index:10; line-height:1.4; transition:all .1s; }
@keyframes neonPulse { 0%{color:#fff; text-shadow:0 0 15px #00ffaa,0 0 30px #00ffaa} 50%{color:#ffcc00;text-shadow:0 0 10px #ffcc00,0 0 20px #ffcc00} 100%{color:#00ffaa; text-shadow:0 0 5px #00ffaa,0 0 10px #00ffaa} }
.level-up-pulse { animation:neonPulse .5s ease-in-out 2; }
#message-box { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,.9); border:3px solid #ff55aa; border-radius:10px; padding:25px; text-align:center; color:#ff55aa; z-index:20; box-shadow:0 0 15px rgba(255,85,170,.8); display:none; }
#message-box h2{font-size:2rem;margin-bottom:10px;}
#message-box p{margin-bottom:20px;font-size:1rem;}
#restart-button { background-color:#ff55aa;color:#161b22;padding:10px 20px;border-radius:6px;cursor:pointer;font-size:1rem;font-weight:bold;box-shadow:0 3px #cc4488; }
#restart-button:active { background-color:#cc4488; box-shadow:0 0 #cc4488; transform:translateY(3px); }
</style>
</head>
<body>

<div id="game-container">
  <div id="score-display">Level: 1 <br> Score: 0</div>
  <canvas id="game-canvas"></canvas>

  <div id="message-box">
    <h2>MISSION FAILED</h2>
    <p id="final-score">Your final score was: 0</p>
    <button id="restart-button">RESTART MISSION</button>
  </div>

  <div class="game-controls md:hidden">
    <button class="control-button" id="left-button">← LEFT</button>
    <button class="control-button" id="right-button">RIGHT →</button>
  </div>
</div>

<script>
// --- Setup and Initialization ---
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('score-display');
const messageBox = document.getElementById('message-box');
const finalScoreText = document.getElementById('final-score');
const restartButton = document.getElementById('restart-button');
const leftButton = document.getElementById('left-button');
const rightButton = document.getElementById('right-button');

let gameLoopId;
let particleLoopId;
let lastTime = 0;
let gameRunning = false;
let score = 0;
let continuousDifficulty = 1.0;
let previousLevel = 1;

const KEYS = { LEFT: 'ArrowLeft', RIGHT: 'ArrowRight', A: 'a', D: 'd', SPACE: ' ' };
let inputState = { left: false, right: false };

const player = {
  x: 0,
  y: 0,
  width: 30,
  height: 30,
  speed: 5,
  color: '#ff55aa'
};

let tacos = [];
let particles = [];
let tacoSpawnTimer = 0;
const INITIAL_SPAWN_RATE = 60;
const PARTICLE_COUNT = 30;

// --- Audio: load base64.txt and create Audio ---
let gameMusic = null;
fetch('base64.txt')
  .then(r => r.text())
  .then(txt => {
    const cleaned = txt.replace(/\s+/g, '');
    if (cleaned.length > 100) {
      try {
        gameMusic = new Audio('data:audio/mp3;base64,' + cleaned);
        gameMusic.loop = true;
        gameMusic.volume = 1.0;
      } catch (e) {
        console.warn('Failed to create audio from base64:', e);
      }
    } else {
      console.warn('base64.txt seems short or invalid.');
    }
  })
  .catch(err => console.warn('Could not fetch base64.txt:', err));

// --- Utility / Resize ---
function resizeCanvas() {
  const aspectRatio = 4/3;
  let newWidth = Math.min(window.innerWidth * 0.9, 700);
  let newHeight = newWidth / aspectRatio;
  if (newHeight > window.innerHeight * 0.7) {
    newHeight = window.innerHeight * 0.7;
    newWidth = newHeight * aspectRatio;
  }
  canvas.width = newWidth;
  canvas.height = newHeight;
  player.x = (canvas.width - player.width) / 2;
  player.y = canvas.height - player.height - 20;
}

// --- Particle class (unchanged) ---
class Particle {
  constructor(x,y,color){
    this.x=x; this.y=y;
    this.size = Math.random()*3+1;
    this.color=color;
    this.life=60;
    this.vx = (Math.random()-0.5)*5;
    this.vy = (Math.random()-0.5)*5;
  }
  update(){ this.x+=this.vx; this.y+=this.vy; this.life--; }
  draw(ctx){
    ctx.fillStyle=this.color;
    ctx.shadowBlur=5; ctx.shadowColor=this.color;
    ctx.fillRect(this.x,this.y,this.size,this.size);
    ctx.shadowBlur=0;
  }
}

// --- Taco (replaces Asteroid) ---
class Taco {
  constructor(canvasWidth, currentDifficulty) {
    this.size = 12 + Math.random() * 18; // visual size
    this.radius = this.size * 0.7; // collision radius
    this.x = Math.random() * (canvasWidth - this.size * 2) + this.size;
    this.y = -this.size * 2;
    this.speed = 1.8 + Math.random() * 1.6 + (currentDifficulty * 1.2);
    this.color = '#FFB400'; // shell color
    this.angle = Math.random() * Math.PI * 2;
    this.angularSpeed = 0.1 + Math.random() * 0.25; // speed of rotation
  }
  update(deltaTime){
    this.y += this.speed * deltaTime / 16;
    this.angle += this.angularSpeed * deltaTime / 16;
  }
  draw(ctx){
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);

    // Draw taco shell (a filled semi-ellipse)
    ctx.beginPath();
    ctx.ellipse(0, 0, this.size, this.size * 0.6, 0, Math.PI, 0, true);
    ctx.fillStyle = this.color;
    ctx.shadowBlur = 8;
    ctx.shadowColor = this.color;
    ctx.fill();
    ctx.shadowBlur = 0;

    // Inside filling - lettuce (green arc)
    ctx.beginPath();
    ctx.ellipse(0, -2, this.size * 0.9, this.size * 0.35, 0, Math.PI, 0, true);
    ctx.fillStyle = '#6FCF97';
    ctx.fill();

    // Toppings - little red dots (tomato) and cheese bits
    for (let i = -3; i <= 3; i++) {
      ctx.beginPath();
      const tx = (i / 3) * this.size * 1.1 + Math.sin(this.angle + i) * 1.2;
      const ty = -Math.random() * this.size * 0.15 - 2;
      ctx.fillStyle = '#E05555';
      ctx.fillRect(tx - 2, ty - 2, 4, 4);
    }
    for (let i = -2; i <= 2; i++) {
      ctx.beginPath();
      const cx = (i / 2) * this.size * 0.9;
      const cy = -Math.random() * this.size * 0.25 - 4;
      ctx.fillStyle = '#FFD166';
      ctx.fillRect(cx - 2, cy - 1, 3, 3);
    }

    ctx.restore();
  }
}

// --- Drawing functions ---
function drawPlayer() {
  if (!gameRunning) return;
  const pw = player.width, ph = player.height, px = player.x, py = player.y;
  ctx.fillStyle = player.color;
  ctx.shadowBlur = 15; ctx.shadowColor = player.color;

  ctx.beginPath();
  ctx.moveTo(px + pw * 0.5, py);
  ctx.lineTo(px + pw * 0.7, py + ph * 0.1);
  ctx.lineTo(px + pw * 0.7, py + ph * 0.7);
  ctx.lineTo(px + pw, py + ph * 0.8);
  ctx.lineTo(px + pw * 0.7, py + ph);
  ctx.lineTo(px + pw * 0.3, py + ph);
  ctx.lineTo(px * 1, py + ph * 0.8);
  ctx.lineTo(px + pw * 0.3, py + ph * 0.7);
  ctx.lineTo(px + pw * 0.3, py + ph * 0.1);
  ctx.lineTo(px + pw * 0.5, py);
  ctx.closePath();
  ctx.fill();

  ctx.shadowBlur = 0;
  ctx.fillStyle = '#ffcc00';
  ctx.beginPath();
  ctx.moveTo(px + pw * 0.35, py + ph);
  ctx.lineTo(px + pw * 0.65, py + ph);
  ctx.lineTo(px + pw * 0.5, py + ph + 15);
  ctx.closePath();
  ctx.fill();

  ctx.shadowBlur = 10;
  ctx.shadowColor = '#ffcc00';
  ctx.fillStyle = '#ffffff80';
  ctx.beginPath();
  ctx.moveTo(px + pw * 0.4, py + ph);
  ctx.lineTo(px + pw * 0.6, py + ph);
  ctx.lineTo(px + pw * 0.5, py + ph + 10);
  ctx.closePath();
  ctx.fill();
  ctx.shadowBlur = 0;
}

function drawTacos() { tacos.forEach(t => t.draw(ctx)); }
function drawParticles() { particles.forEach(p => p.draw(ctx)); }

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // subtle star field
  for (let i = 0; i < 50; i++) {
    ctx.fillStyle = `rgba(255,255,255,${Math.random()})`;
    ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 1, 1);
  }
  drawPlayer();
  drawTacos();
  drawParticles();
}

// --- Game Logic ---
function handleInput(){
  if (inputState.left) player.x = Math.max(0, player.x - player.speed);
  if (inputState.right) player.x = Math.min(canvas.width - player.width, player.x + player.speed);
}

function updateParticles(){
  particles.forEach(p => p.update());
  particles = particles.filter(p => p.life > 0);
}

function checkCollision(player, taco){
  const playerCenterX = player.x + player.width/2;
  const playerCenterY = player.y + player.height/2;
  const dx = playerCenterX - taco.x;
  const dy = playerCenterY - taco.y;
  const distance = Math.sqrt(dx*dx + dy*dy);
  return distance < taco.radius + (player.width * 0.4);
}

function updateTacos(deltaTime) {
  tacos.forEach(t => t.update(deltaTime));

  tacos = tacos.filter(t => {
    if (t.y > canvas.height + t.size) return false;
    if (checkCollision(player, t) && gameRunning) {
      endGame();
      return false;
    }
    return true;
  });

  tacoSpawnTimer++;
  let currentSpawnRate = INITIAL_SPAWN_RATE / continuousDifficulty;
  if (tacoSpawnTimer > currentSpawnRate) {
    tacos.push(new Taco(canvas.width, continuousDifficulty));
    tacoSpawnTimer = 0;
  }
}

function updateScore(deltaTime) {
  score += deltaTime / 100;
  continuousDifficulty = 1.0 + (score / 500);
  const currentLevel = 1 + Math.floor(score / 500);
  if (currentLevel > previousLevel) {
    scoreDisplay.classList.add('level-up-pulse');
    setTimeout(()=> scoreDisplay.classList.remove('level-up-pulse'), 1000);
  }
  previousLevel = currentLevel;
  scoreDisplay.innerHTML = `Level: ${currentLevel} <br> Score: ${Math.floor(score)}`;
  player.speed = 5 + (continuousDifficulty * 0.5);
}

function gameLoop(currentTime){
  if (!gameRunning) return;
  const deltaTime = currentTime - lastTime;
  lastTime = currentTime;
  handleInput();
  updateTacos(deltaTime);
  updateScore(deltaTime);
  updateParticles();
  draw();
  gameLoopId = requestAnimationFrame(gameLoop);
}

function createExplosion(x, y, color){
  for (let i = 0; i < PARTICLE_COUNT; i++) particles.push(new Particle(x,y,color));
}

function startGame(){
  if (gameRunning) return;

  // start audio if loaded
  if (gameMusic) {
    try { gameMusic.currentTime = 0; gameMusic.play().catch(e => console.log('Audio play blocked', e)); }
    catch(e){ console.warn('Audio start failed', e); }
  }

  score = 0;
  continuousDifficulty = 1.0;
  previousLevel = 1;
  tacos = [];
  particles = [];
  player.x = (canvas.width - player.width)/2;
  player.y = canvas.height - player.height - 20;
  gameRunning = true;
  messageBox.style.display = 'none';
  scoreDisplay.innerHTML = `Level: 1 <br> Score: 0`;

  lastTime = performance.now();
  gameLoopId = requestAnimationFrame(gameLoop);
}

function endGame(){
  gameRunning = false;
  cancelAnimationFrame(gameLoopId);
  cancelAnimationFrame(particleLoopId);

  // stop audio
  if (gameMusic) {
    try { gameMusic.pause(); }
    catch(e){ console.warn('Audio pause failed', e); }
  }

  const centerX = player.x + player.width/2;
  const centerY = player.y + player.height/2;
  createExplosion(centerX, centerY, player.color);

  const particleLoop = (time) => {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    updateParticles();
    drawTacos();
    drawParticles();
    if (particles.length > 0) {
      particleLoopId = requestAnimationFrame(particleLoop);
    } else {
      finalScoreText.textContent = `Your final score was: ${Math.floor(score)}`;
      messageBox.style.display = 'block';
    }
  };
  particleLoopId = requestAnimationFrame(particleLoop);
}

// --- Input handlers & setup ---
document.addEventListener('keydown', (e) => {
  if (!gameRunning) {
    if (e.key === KEYS.SPACE) startGame();
    return;
  }
  if (e.key === KEYS.LEFT || e.key === KEYS.A) inputState.left = true;
  if (e.key === KEYS.RIGHT || e.key === KEYS.D) inputState.right = true;
});
document.addEventListener('keyup', (e) => {
  if (e.key === KEYS.LEFT || e.key === KEYS.A) inputState.left = false;
  if (e.key === KEYS.RIGHT || e.key === KEYS.D) inputState.right = false;
});

function setupButton(button, direction) {
  const startMove = () => { inputState[direction] = true; };
  const stopMove = () => { inputState[direction] = false; };
  button.addEventListener('mousedown', startMove);
  button.addEventListener('mouseup', stopMove);
  button.addEventListener('mouseleave', stopMove);
  button.addEventListener('touchstart', (e)=>{ e.preventDefault(); startMove(); });
  button.addEventListener('touchend', stopMove);
  button.addEventListener('touchcancel', stopMove);
}
setupButton(leftButton, 'left');
setupButton(rightButton, 'right');

restartButton.addEventListener('click', startGame);
window.addEventListener('resize', resizeCanvas);

// Start game on load
window.onload = function(){
  resizeCanvas();
  finalScoreText.innerHTML = 'Press **SPACE** on desktop or **TAP RESTART** to begin.';
  messageBox.style.display = 'block';
  gameRunning = false;
};
</script>
</body>
</html>
